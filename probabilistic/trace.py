import inspect
import copy
import random
from collections import Counter

class RandomVariableRecord:
	"""
	Variables generated by ERPs.
	These form the 'choice points' in a probabilistic program trace.
	"""

	def __init__(self, erp, params, val, logprob, structural, conditioned=False):
		self.erp = erp
		self.params = params
		self.val = val
		self.logprob = logprob
		self.active = True
		self.conditioned = conditioned
		self.structural = structural

	def __deepcopy__(self, memo):
		return RandomVariableRecord(self.erp, self.params[:], self.val, self.logprob, self.structural, self.conditioned)

class RandomExecutionTrace:
	"""
	Execution trace generated by a probabilistic program.
	Tracks the random choices made and accumulates probabilities
	"""

	def __init__(self):
		self._vars = {}
		self.logprob = 0
		self.newlogprob = 0		# From newly-added variables
		self.oldlogprob = 0		# From unreachable variables
		self.rootframe = None
		self.loopcounters = Counter()
		self.conditionsSatisfied = True

	def __deepcopy__(self, memo):
		newdb = RandomExecutionTrace()
		newdb.logprob = self.logprob
		newdb.oldlogprob = self.oldlogprob
		newdb.newlogprob = self.newlogprob
		newdb._vars = copy.deepcopy(self._vars, memo)
		newdb.conditionsSatisfied = self.conditionsSatisfied
		return newdb

	def numVars(self):
		return len(self._vars)

	def randomFreeVar(self):
		"""
		Returns a randomly-chosen free variable from the trace
		Technically, returns a (name, record) pair
		"""
		freeVars = filter(lambda tup: not tup[1].conditioned, self._vars.iteritems())
		if len(freeVars) == 0:
			return None
		else:
			return random.choice(filter(lambda tup: not tup[1].conditioned, self._vars.iteritems()))

	def traceUpdate(self, computation):
		"""
		Run computation and update this database accordingly
		"""

		global _trace
		originalTrace = _trace
		_trace = self

		self.logprob = 0.0
		self.newlogprob = 0.0
		self.loopcounters.clear()
		self.conditionsSatisfied = True

		# First, mark all random values as 'inactive'; only
		# those reeached by the computation will become 'active'
		for record in self._vars.values():
			record.active = False

		# Mark that this is the 'root' of the current execution trace
		self.rootframe = inspect.currentframe()

		# Run the computation, which will create/lookup random variables
		retval = computation()

		# CLear out the root frame, etc.
		self.rootframe = None
		self.loopcounters.clear()

		# Clean up any random values that are no longer reachable
		self.oldlogprob = 0.0
		for record in self._vars.values():
			if not record.active:
				self.oldlogprob += record.logprob
		self._vars = {name:record for name,record in self._vars.iteritems() if record.active}

		_trace = originalTrace

		return retval

	def currentName(self, numFrameSkip):
		"""
		Return the current name, as determined by the interpreter
			stack of the current program.
		Skips the top 'numFrameSkip' stack frames that precede this
			function's stack frame (numFrameSkip+1 frames total)
		"""
		numFrameSkip += 1	# Skip this frame, obviously
		f = inspect.currentframe()
		i = 0
		while i < numFrameSkip:
			i += 1
			f = f.f_back
		name = ""
		while f != None and f != self.rootframe:
			name = "{0}:{1}:{2}:{3}|".format(id(f.f_code), self.loopcounters[id(f)], f.f_lineno, f.f_lasti) + name
			f = f.f_back
		return name

	def incrementLoopCounter(self, numFrameSkip):
		"""
		Increment the loop counter associated with the frame that is numFrameSkip
		frames from the top of the stack
		"""
		numFrameSkip += 1	# Skip this frame, obviously
		f = inspect.currentframe()
		i = 0
		while i < numFrameSkip:
			i += 1
			f = f.f_back
		self.loopcounters[id(f)] += 1

	def lookup(self, name, erp, params, isStructural, conditionedValue=None):
		"""
		Looks up the value of a random variable.
		If this random variable does not exist, create it
		"""

		record = self._vars.get(name)
		if (record == None or record.erp != erp or
			isStructural != record.structural or
			(conditionedValue != None and conditionedValue != record.val)):
			# Create new variable
			val = None
			if conditionedValue == None:
				val = erp._sample_impl(params)
			else:
				val = conditionedValue
			ll = erp._logprob(val, params)
			self.newlogprob += ll
			record = RandomVariableRecord(erp, params, val, ll, isStructural, conditionedValue != None)
			self._vars[name] = record
		else:
			# Reuse existing variable
			if record.params != params:
				record.params = params
				record.logprob = erp._logprob(record.val, params)
		self.logprob += record.logprob
		record.active = True
		return record.val

	def getRecord(self, name):
		"""
		Simply retrieve the variable record associated with name
		"""
		return self._vars.get(name)

	def addFactor(self, num):
		"""
		Add a new factor into the log likelihood of the current trace
		"""
		self.logprob += num

	def conditionOn(self, boolexpr):
		"""
		Condition the trace on the value of a boolean expression
		"""
		self.conditionsSatisfied = self.conditionsSatisfied and boolexpr

"""
Global singleton instance
"""
_trace = None

def lookupVariableValue(erp, params, isStructural, numFrameSkip, conditionedValue=None):
	global _trace
	if _trace == None:
		if conditionedValue == None:
			return erp._sample_impl(params)
		else:
			return conditionedValue
	else:
		name = _trace.currentName(numFrameSkip+1)
		return _trace.lookup(name, erp, params, isStructural, conditionedValue)

def incrementLoopCounter(numFrameSkip):
	global _trace
	if _trace != None:
		_trace.incrementLoopCounter(numFrameSkip+1)

def newTrace():
	return RandomExecutionTrace()

def factor(num):
	global _trace
	if _trace != None:
		_trace.addFactor(num)

def condition(boolexpr):
	global _trace
	if _trace != None:
		_trace.conditionOn(boolexpr)