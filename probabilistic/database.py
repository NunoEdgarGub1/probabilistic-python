import inspect
import copy
import random

class _RVDatabaseRecord:
	"""
	Value item stored in the database
	"""

	def __init__(self, erp, params, val, logprob):
		self.erp = erp
		self.params = params
		self.val = val
		self.logprob = logprob
		self.active = True

	def __deepcopy__(self, memo):
		return _RVDatabaseRecord(self.erp, self.params[:], self.val, self.logprob)

class _RandomVariableDatabase:
	"""
	Database of randomness generated by a probabilistic program
	Modified/updated during inference over program traces
	"""

	def __init__(self):
		self._vars = {}
		self.logprob = 0

	def __deepcopy__(self, memo):
		newdb = _RandomVariableDatabase()
		newdb.logprob = self.logprob
		newdb._vars = copy.deepcopy(self._vars, memo)
		return newdb

	def numVars(self):
		return len(self._vars)

	def chooseVariableRandomly(self):
		"""
		Returns a randomly-chosen variable from the trace
		Technically, returns a (name, record) pair
		"""
		name = random.choice(self._vars.keys())
		return (name, self._vars[name])

	def traceUpdate(self, computation):
		"""
		Run computation and update this database accordingly
		"""

		self.logprob = 0.0

		# First, mark all random values as 'inactive'; only
		# those reeached by the computation will become 'active'
		for record in self._vars.values():
			record.active = False

		retval = computation()

		# Clean up any random values that are no longer reachable
		self._vars = {name:record for name,record in self._vars.iteritems() if record.active}

		return retval

	def currentName(self, numFrameSkip):
		"""
		Return the current name, as determined by the execution
			trace of the current program.
		Skips the top 'numFrameSkip' stack frames that precede this
			function's stack frame (numFrameSkip+1 frames total)
		"""
		s = inspect.stack()[(numFrameSkip+1):]
		s.reverse()
		name = ""
		for tup in s:
			f = tup[0]
			name += "{0}:{1}|".format(id(f.f_code), f.f_lineno)
		return name

	def lookup(self, name, erp, params):
		"""
		Looks up the value of a random variable.
		If this random variable does not exist, returns None.
		"""
		record = self._vars.get(name)
		if record == None or record.erp != erp:
			return None
		else:
			if record.params != params:
				record.params = params
				record.logprob = erp._logprob(params)
			self.logprob += record.logprob
			record.active = True
			return record.val

	def getRecord(self, name):
		"""
		Simply retrieve the variable record associated with name
		"""
		return self._vars.get(name)

	def insert(self, name, erp, params, val):
		"""
		Insert a new random variable
		"""
		ll = erp._logprob(val, params)
		self._vars[name] = _RVDatabaseRecord(erp, params, val, ll)
		self.logprob += ll

	def addFactor(self, num):
		"""
		Add a new factor into the log likelihood of the current trace
		"""
		self.logprob += num

"""
Global singleton instance
"""
_rvdb = _RandomVariableDatabase()